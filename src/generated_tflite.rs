// This file is automatically generated, DO NOT EDIT
//
// To regenerate this file run the `crates/witx-bindgen` command

use core::fmt;
use core::mem::MaybeUninit;
#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct WasmedgeTfliteErrno(u32);
pub const WASMEDGE_TFLITE_ERRNO_SUCCESS: WasmedgeTfliteErrno = WasmedgeTfliteErrno(0);
pub const WASMEDGE_TFLITE_ERRNO_INVALID_ARGUMENT: WasmedgeTfliteErrno = WasmedgeTfliteErrno(1);
pub const WASMEDGE_TFLITE_ERRNO_INVALID_ENCODING: WasmedgeTfliteErrno = WasmedgeTfliteErrno(2);
pub const WASMEDGE_TFLITE_ERRNO_MISSING_MEMORY: WasmedgeTfliteErrno = WasmedgeTfliteErrno(3);
pub const WASMEDGE_TFLITE_ERRNO_BUSY: WasmedgeTfliteErrno = WasmedgeTfliteErrno(4);
pub const WASMEDGE_TFLITE_ERRNO_RUNTIME_ERROR: WasmedgeTfliteErrno = WasmedgeTfliteErrno(5);
impl WasmedgeTfliteErrno {
    pub const fn raw(&self) -> u32 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "SUCCESS",
            1 => "INVALID_ARGUMENT",
            2 => "INVALID_ENCODING",
            3 => "MISSING_MEMORY",
            4 => "BUSY",
            5 => "RUNTIME_ERROR",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            2 => "",
            3 => "",
            4 => "",
            5 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for WasmedgeTfliteErrno {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("WasmedgeTfliteErrno")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}
impl fmt::Display for WasmedgeTfliteErrno {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} (error {})", self.name(), self.0)
    }
}

#[cfg(feature = "std")]
extern crate std;
#[cfg(feature = "std")]
impl std::error::Error for WasmedgeTfliteErrno {}

pub type ModelBuffer<'a> = &'a [u8];
pub type Session = u32;
pub type Tensor = u32;
pub type TensorSize = u32;
pub type TensorData<'a> = &'a [u8];
pub unsafe fn create_session(
    model_buffer: ModelBuffer<'_>,
) -> Result<Session, WasmedgeTfliteErrno> {
    let mut rp0 = MaybeUninit::<Session>::uninit();
    let ret = wasmedge_tensorflowlite::create_session(
        model_buffer.as_ptr() as i32,
        model_buffer.len() as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Session)),
        _ => Err(WasmedgeTfliteErrno(ret as u32)),
    }
}

pub unsafe fn delete_session(session: Session) -> Result<(), WasmedgeTfliteErrno> {
    let ret = wasmedge_tensorflowlite::delete_session(session as i32);
    match ret {
        0 => Ok(()),
        _ => Err(WasmedgeTfliteErrno(ret as u32)),
    }
}

pub unsafe fn run_session(session: Session) -> Result<(), WasmedgeTfliteErrno> {
    let ret = wasmedge_tensorflowlite::run_session(session as i32);
    match ret {
        0 => Ok(()),
        _ => Err(WasmedgeTfliteErrno(ret as u32)),
    }
}

pub unsafe fn get_output_tensor(
    session: Session,
    name: &str,
) -> Result<Tensor, WasmedgeTfliteErrno> {
    let mut rp0 = MaybeUninit::<Tensor>::uninit();
    let ret = wasmedge_tensorflowlite::get_output_tensor(
        session as i32,
        name.as_ptr() as i32,
        name.len() as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Tensor)),
        _ => Err(WasmedgeTfliteErrno(ret as u32)),
    }
}

pub unsafe fn get_tensor_len(
    session: Session,
    tensor: Tensor,
) -> Result<TensorSize, WasmedgeTfliteErrno> {
    let mut rp0 = MaybeUninit::<TensorSize>::uninit();
    let ret = wasmedge_tensorflowlite::get_tensor_len(
        session as i32,
        tensor as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const TensorSize)),
        _ => Err(WasmedgeTfliteErrno(ret as u32)),
    }
}

pub unsafe fn get_tensor_data(
    session: Session,
    tensor: Tensor,
    tensor_buf: *mut u8,
    tensor_buf_max_size: TensorSize,
) -> Result<TensorSize, WasmedgeTfliteErrno> {
    let mut rp0 = MaybeUninit::<TensorSize>::uninit();
    let ret = wasmedge_tensorflowlite::get_tensor_data(
        session as i32,
        tensor as i32,
        tensor_buf as i32,
        tensor_buf_max_size as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const TensorSize)),
        _ => Err(WasmedgeTfliteErrno(ret as u32)),
    }
}

pub unsafe fn append_input(
    session: Session,
    name: &str,
    tensor_buf: TensorData<'_>,
) -> Result<(), WasmedgeTfliteErrno> {
    let ret = wasmedge_tensorflowlite::append_input(
        session as i32,
        name.as_ptr() as i32,
        name.len() as i32,
        tensor_buf.as_ptr() as i32,
        tensor_buf.len() as i32,
    );
    match ret {
        0 => Ok(()),
        _ => Err(WasmedgeTfliteErrno(ret as u32)),
    }
}

pub mod wasmedge_tensorflowlite {
    #[link(wasm_import_module = "wasmedge_tensorflowlite")]
    extern "C" {
        pub fn create_session(arg0: i32, arg1: i32, arg2: i32) -> i32;
        pub fn delete_session(arg0: i32) -> i32;
        pub fn run_session(arg0: i32) -> i32;
        pub fn get_output_tensor(arg0: i32, arg1: i32, arg2: i32, arg3: i32) -> i32;
        pub fn get_tensor_len(arg0: i32, arg1: i32, arg2: i32) -> i32;
        pub fn get_tensor_data(arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32) -> i32;
        pub fn append_input(arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32) -> i32;
    }
}
